<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0076)https://www2.cs.sfu.ca/CourseCentral/225/alavergn/Labs/Lab1/1-Cpp_class.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>CMPT 225 - Lab 1: C++ Class</title>
   <link rel="stylesheet" href="./CMPT 225 - Lab 1_ C++ Class_files/basic.css">
   <link rel="stylesheet" href="./CMPT 225 - Lab 1_ C++ Class_files/lab_style.css" type="text/css" title="Basic Style" media="print,screen,projection" id="basic-style">  
    <link rel="icon" href="https://www2.cs.sfu.ca/CourseCentral/225/alavergn/Images/favicon.ico" type="image/x-icon">
   <meta name="author" content="Anne Lavergne">  
   <meta http-equiv="Content-Style-Type" content="text/css" charset="UTF-8&quot;/">  
</head>

<body data-new-gr-c-s-check-loaded="14.1152.0" data-gr-ext-installed="">

<h1 style="text-align:right">CMPT 225 - Lab 1: C++ Class</h1>      
    
<div class="plain">
   
<!--<p><font color="red">If you do not have time to complete this lab during the lab session, 
you can finish it on your own either at home or in the CSIL lab.</font>-->
   
<hr> 
<hr>
<h2>Recommendation</h2>

<p>We suggest you read the entire Lab 1 before jumping into solving the problem outlined in this lab.</p>
<p>Why? Because then you will have discovered the way this lab is structured and that there is a section that explains
how to write classes in C++ right after the section in which you are given a problem to solve.</p>

<hr>
<h2>Lab Preparation</h2>

  <p>Steps:
</p><ul>
<li><p>Within your <b>sfuhome/cmpt-225</b> directory, create a <b>Lab1</b> folder.</p></li>
<li><p><b>cd</b> into <b>sfuhome/cmpt-225/Lab1</b>.</p></li>
<li><p>Download into this current folder any files you are asked to download as part of this lab. If you are asked to download a 
    <b>zip</b> file, make sure you extract its content first. Never edit files that are still part of a <b>zip</b> file
    and have not yet been extracted from it.</p></li>
<li><p>Make sure you save all the files you create as part of Lab 1 in this folder: <b>sfuhome/cmpt-225/Lab1</b>.</p></li>
</ul>
<p></p>

<hr>

<h2>General Requirements</h2>

For all programs you shall write this semester, here is a list of general requirements which must always be satisfied, 
unless there is a requirement that explicitly states otherwise in the lab.
<ul>
<li><p>If you need to use a literal value (i.e., “hard code” a literal value), you must declare it as a constant.</p></li>
<li><p>You must descriptively name ...
</p><ul>
<li><p>Your program (implementation file, i.e., the file with a .cpp extension), executable file and classes</p></li>
<li><p>Your constants, local variables, parameters and member attributes (x, y, a, b are usually not descriptive variables names)</p></li>
<li><p>Your functions and member methods of a class</p></li>
</ul>
<p></p></li>
<li><p>Your user interface must clearly describe the expected input to the user (which input you are expecting the use to enter, 
its format and range of value, if possible) and the resulting output.</p></li>
<li><p>You must comment your programs.</p></li>
<li><p>You must indent the statements in your programs.</p></li> 
<li><p>You must include a header comment block at the top of each of your source files listing the name of the source file,
 a description of the program found in the source file, the name of the author of the program (this should be you) and 
 the date of creation of the source file/program.</p></li>
<li><p>When creating classes, you must put the class member attributes (also called "data members") and member method declarations 
(also called "headers" or "prototypes") in a header file (.h extension) 
 and the implementation of the class member methods (and functions) in an implementation (or source) file (.cpp extension).</p><p></p></li>
<li><p>You must give your source files (e.g., class implementation files and test driver files) a .cpp extension and your header files a .h extension (when writing C++ code).</p></li>
<li><p>You must not use <b>goto</b> statements.</p></li>
<li><p>You must construct proper conditions for your conditional and iteration statements, unlike: <b>while ( 1 )</b>.</p></li>
</ul>

<hr>

<h2>Circles - Problem Statement and Requirements</h2>

<p>Write a complete C++ ADT class to represent a circle in two-dimensional Cartesian space. 
You locate this circle in this space by specifying the coordinates (x,y) of its centre.</p> 

<p>Your class must consist of a header file (<b>Circle.h</b>) and an
implementation file (<b>Circle.cpp</b>) as described below. The Circle
class must have the following (private) member attributes and (public) operations
(i.e., member methods):</p>

<hr>
<h3>Attributes</h3>

<p>The Circle class must have the following (private) member attributes:</p>
<ul>
	<li><p>x coordinate (an int), can be negative<br></p></li>
	<li><p>y coordinate (an int), can be negative<br></p></li>
	<li><p>radius (a double), must be greater than 0.0<br></p></li>
</ul>


<hr>

<h3>Operations</h3>

<p>The Circle class must have the following (public) operations (i.e., member methods):</p>

<ul>
	<li><p>A default constructor that creates a circle of radius 10 and centred at coordinates (0,0)</p></li>
	<li><p>A constructor with parameters for x, y, and radius<br></p></li>
	<li><p>Do you need a destructor?<br></p></li>
	<li><p>int getX() - returns the circle's centre x coordinate</p></li>
	<li><p>int getY() - returns the circle's centre y coordinate</p></li>
	<li><p>double getRadius() - returns the circle's radius</p></li>
	<li><p>void move(int horiz, int vert) - moves the circle to the new given location (horiz,vert) (therefore changing its x and y member attributes to the given horiz and vert parameter values, respectively)</p></li>
	<li><p>void setRadius(double r) - changes the circle's radius to r, or to 10.0 if r is invalid<br></p></li>
	<li><p>double computeArea() - computes and returns the circle's area<br></p></li>
	<li><p>void displayCircle() - displays the circle's member attributes like this: <b> x = 0, y = 11, radius = 0.2</b><br></p></li>
	<li><p>bool intersect(Circle c) - returns true if c intersects the calling circle<br></p></li>
</ul>

	                                                     
<hr>
<hr>

<h2>Writing a C++ ADT Class<br></h2>

<h3>.h and .cpp Files<br></h3>

<p>C++ ADT classes are made up of a header file and an implementation file.&nbsp;
Both files should have the same name except that the header file has a
.h extension while the implementation (code) file has a .cpp extension. The header
file contains the class definition, i.e., the class name,
the name (and type) of the member attributes and the declaration (header or prototype) for each of
the class member methods. The .cpp file consists of the implementation of these class member methods.</p>
<p> 
Finally, both files must contain the same class documentation: a header comment block at the top
of each file as well as description, precondition (if any) and postcondition (if any) for 
each method.</p>

<hr>

<h3>Public or Private?<br></h3>

<p>Class member attributes and methods should be categorised as being either <b>private</b> or <b>public</b>.
Private member attributes and methods can only be accessed from within the
class, whereas public member attributes and methods can be accessed from
outside the class, i.e., from client code. There are a couple of good general design
principles to follow when deciding whether or not to make a member attribute or member method public:</p>

<ul>
   <li><p>Only make something public if it needs to be public, i.e., accessible by client code (code outside this class).</p></li>
   <li><p>Designed classes as ADT classes: make all member attributes private (behind the wall) and provide public getter and
      setter member methods for each member attributes, if appropriate. This way, you can ensure that any class invariants are 
	  maintained (e.g. such as ensuring that a circle's radius is a positive number) by adding validation code
	  in the implementation of the setter member methods, as well as in other member methods, if appropriate.</p></li>
</ul>

<hr>

<h3>Constructors and Destructors</h3>

<p>Every class requires a constructor to create new objects of that
class. A class will often have multiple constructors that build
new objects in slightly different ways: a default constructor and some parameterised constructors.
A constructor is a method that has exactly the same name as the class and has no return type. It
is responsible for constructing (instantiating) an object of the class and setting the initial values of the member attributes of this object.<br></p>

<p>C++ classes require destructors. A destructor is responsible for de-allocating any dynamically allocated memory that an
object uses. If you don't write a destructor for a class a
default one is created for you. It is OK to rely on the default
destructor if your class does not use any dynamically allocated memory. However, if your class does, 
then you must implement a destructor.</p>

<hr>
<h3>Syntax</h3>

<p>It's easier to show the syntax by presenting a simple example. Here is a class
that models a rectangle. It has the following member attributes and methods:</p>

<ul>
<li><p>height</p></li>
<li><p>width</p></li>
<li><p>Rectangle - constructor to create a new rectangle with the given height and width<br></p></li>
<li><p>getHeight - returns the height of the rectangle</p></li>
<li><p>getWidth - returns the width of the rectangle</p></li>
<li><p>setHeight - sets the height of the rectangle</p></li>
<li><p>setWidth - sets the width of the rectangle</p></li>
<li><p>computeArea - computes and returns the area of the rectangle<br></p></li>
<li><p>displayRectangle - prints the height and width of the rectangle<br></p></li>
</ul>

<p>Here is its header file: <!--, C++ keywords are in bold.--><br></p>

<pre>/*
* Rectangle.h
*
* Description: This class models a rectangle ...
* Class Invariant: ???
*
* Author:
* Creation date:
*/

class Rectangle {

private: 

   // Everything that follows is private and cannot be "seen" and 
   // directly accessed from outside the class (from client code).
   // To access these private member attributes, client code needs to use the getters and setters.
  
   unsigned int width;
   unsigned int height;
   
   // Some classes have private member methods like our Temperature class. This one doesn't!

public: 

   // Everything that follows is public and can be "seen" and directly accessed 
   // from outside the class (from client code).
   
   // Default constructor
   // Note that the default constructor has no parameters.
   Rectangle(); 
   
   // Parameterized constructor
   // Description: Create a new rectangle with the given values.
   Rectangle(unsigned int w, unsigned int h);
      
   // Getters return information about the rectangle. 
   // Note the <b>const</b> at the end of each of the methods.
   // This guarantees that a method will not alter the member attributes as it executes.
   unsigned int getWidth() const;
   unsigned int getHeight() const;

   // Setters change the values of the class' member attributes.
   void setWidth(unsigned int w);
   void setHeight(unsigned int h);
   
   // Description: Compute and return the area of "this" rectangle.
   unsigned int computeArea() const;   
   
   // Description: Prints the rectangle's height and width.
   void displayRectangle() const;

}; // Note the ";" - don't forget it!
// End of Rectangle.h

</pre>

<p>And here is the implementation file:</p><p>

</p><pre>/*
* Rectangle.cpp
*
* Description: This class models a rectangle ...
* Class Invariant: ???
*
* Author:
* Creation date:
*/

#include &lt;iostream&gt;       // As you need to print data
#include "Rectangle.h"    // The header file for the class - you need this!

using std::cout;          // The implementation of this class uses the object <b>cout</b>
using std::endl;          // and the object <b>endl</b>

// Now, read each of the method implementations. 
// The <b>Rectangle::</b> preceding each method indicates that the method belongs to the Rectangle class. 
// If it is omitted, the compiler will attempt to create a separate function 
// (not belonging to the class). This is not what you want.

// Default constructor
// Note: This part of the constructor's header " : width(1), height(1)"
// is called the "initialization list". 
// Check what our textbook and online resources have to say about it!
Rectangle::Rectangle() : width(1), height(1) { }

// Parameterized constructor
// Description: Create a new rectangle with the given values.
Rectangle::Rectangle(unsigned int w, unsigned int h)
{
   if (w &gt; 0)
      width = w; // Don't need {}s if there is only one line in the body.
   else
      width = 1;

   if (h &gt; 0){
      height = h; // But you can use them if you want.
   }else{
      height = 1;
   }
}

// Getters return information about the rectangle. 
// Note the <b>const</b> at the end of each of the methods.
// This guarantees that a method will not alter the member attributes as it executes.
unsigned int Rectangle::getWidth() const
{
   return width;
}

int Rectangle::getHeight() const
{
   return height;
}

// Setters change the values of the class' member attributes.
void Rectangle::setWidth(unsigned int w)
{
   if (w &gt; 0)
      width = w;
   else
      width = 1;
   return;    
}

void Rectangle::setHeight(unsigned int h)
{
   if (h &gt; 0)
      height = h;
   else
      height = 1;
   return; 
}
   
// Description: Compute and return the area of "this" rectangle.
unsigned int Rectangle::computeArea() const   
{
   return width * height;  
}

// Description: Prints the rectangle's height and width.
void Rectangle::displayRectangle() const
{
   cout &lt;&lt; "width = " &lt;&lt; getWidth();
   cout &lt;&lt; ", height = " &lt;&lt; getHeight() &lt;&lt; endl;
   return;
}

// End of the implementation file</pre>

<hr>
<h3>Note</h3>

<p>There is (a lot) more to C++ classes than described above but this is enough to get you started.</p>

<br>
<hr>
<hr>


<h2>Compiling and Running</h2>

<p>Go ahead and implement your Circle class.</p>

<p>If you actually want to use and test your Circle class, you will
need a main function (contained in its own file), 
which you will compile with your Circle class files. This
program is often known as a <b>test driver program</b> or simply <b>test driver</b>.

</p><p> As an example, for testing your Circle class we have provided two test driver programs. 
Download <a href="https://www2.cs.sfu.ca/CourseCentral/225/alavergn/Labs/Lab1/Lab1-Files.zip">this zip file</a> and unzip it in your Lab1 directory. This
zip file contains <b>testcirc1.cpp</b> and <b>testcirc2.cpp</b>, the two test driver
programs. Each one creates some Circle object and tests their member methods: 
<b>testcirc1.cpp</b> tests the getters, setters and the <b>computeArea</b> method
 while <b>testcirc2.cpp</b> tests the <b>displayCircle</b> method and the <b>intersect</b> method.</p>

<p>Open these two test driver files in the text editor and have a good look at their content. 
Can you figure out the test cases (test data) these two test drivers are using? 
Can you figure out the results you are expecting (expected results) when you execute these two test drivers?</p>

<hr>
<h3>Compiling the Test Driver program</h3>

<p>Compile these using the following <b>g++</b> commands:
</p><pre>g++ -o testcirc1 Circle.cpp testcirc1.cpp
g++ -o testcirc2 Circle.cpp testcirc2.cpp
</pre>

<p>There is also a test script (again <b>test.py</b>), which you can run as follows:

</p><pre>your_username@hostname:~$ ./test.py</pre> 

<p>If you have correctly built the executables <b>testcirc1</b> and <b>testcirc2</b>, you will see:
</p><pre>Running test 1... passed
Running test 2... passed
Passed 2 of 2 tests.
</pre>
on the computer monitor screen.<p></p>

<p>If you are unable to run <b>test.py</b> because of permission problem, enter the following at the command line:
</p><pre>$ chmod 755 test.py</pre>
<p>This command changes the permission of <b>test.py</b> such that it should now be <b>executable</b>.
Try running <b>test.py</b> again.
If you are curious about this command and how permissions work in Linux, feel free to ask the instructor, 
the TA or the Internet. :)</p>

<p>If you are not seeing the above results on your screen,
you will need to go over your program and figure out
the "bug", fix it and recompile your code.</p>

<p>Now, clean up your directory in order to prepare us for the next section of this lab.
You achieve this by typing:
</p><pre>your_username@hostname:~$ make clean</pre>
<p>This command will remove any <b>.o</b> (object) files as well as the executables
<b>testcirc1</b> and <b>testcirc2</b> you may have already created. We shall come back to the topic of <b>makefiles</b> 
later on in this lab.</p>

<hr>

<h3>Object files</h3>

<p>If you wanted to compile your Circle class on its own, you could do
so. But wait, there's no main function?! You can compile your Circle
class using the <b>-c</b> option in <b>g++</b>:

</p><pre>your_username@hostname:~$ g++ -c Circle.cpp
your_username@hostname:~$ ls C*
Circle.cpp    Circle.h      Circle.o</pre>

<p>But wait, what does it mean to compile a class with no main function?
Why would you want to do such a thing? What is that <b>Circle.o</b> file
that was just created?

</p><p><b>Circle.o</b> is called an <b>object file</b>. One way to think about
object files is that they contain machine instructions for the
member methods in a class.
However, no client code is using these member methods yet, since there is no main
function.

</p><p>Why would you want to do this? (1) To make sure some part of your
code compiles. (2) To reuse the compilation -- don't need to recompile
<b>Circle.cpp</b> if you only change <b>testcirc1.cpp</b> and/or <b>testcirc2.cpp</b>. This may seem trivial in a
small example like this one, but makes a big difference when you are dealing with more
complex software with many classes.

</p><p>For example, you can compile <b>testcirc1.cpp</b> using the <b>Circle.o</b> object file:
</p><pre>your_username@hostname:~$ g++ -o test testcirc1.cpp Circle.o</pre>
<p>You can then execute this new executable as follows:
</p><pre>your_username@hostname:~$ ./test</pre>
<p>Technically, this process involves <b>linking</b>, in which the
compiled machine instructions in <b>Circle.o</b> are linked into the new
executable called <b>test</b>, rather than being recompiled.</p>

<p>Perhaps you're thinking "Hum... This sounds rather troublesome!
 First you need to run a <b>g++</b> command on <b>Circle.cpp</b>, 
 then you need to type in another long <b>g++</b> command
to compile <b>testcirc.cpp</b>."</p>
<p>Would it not be great if there were some way to avoid all this?</p>
<p>Of course, there is.</p>

<hr>
<h3>makefiles</h3>

<p>This is where <b>makefiles</b> come in. <b>makefiles</b> are like recipes
that specify how all the components of an application (software) should be compiled and linked. 
And, by convention, the file is called <b>makefile</b>.
We provided a <b>makefile</b> in <b>Lab1-Files.zip</b> which you downloaded. 
Open this makefile in the text editor and have a good look at its content.</p>

<p>Type the following once again:
</p><pre>your_username@hostname:~$ make clean</pre>
<p>This command will remove the .o file created above.

</p><p>Now try:
</p><pre>your_username@hostname:~$ make testcirc1</pre>

<p>If you have code that properly compiles, you should see:
</p><pre>g++ -Wall -c testcirc1.cpp
g++ -Wall -c Circle.cpp
g++ -Wall testcirc1.o Circle.o -o testcirc1
</pre>

<p>Magic! The recipe in the makefile specifies how to build <b>testcirc1</b>. The
executable <b>testcirc1</b> should now exist.

</p><p>Now try making a small change to <b>testcirc1.cpp</b> (anything at all --
just add an empty line in the file).
If you execute <b>make testcirc1</b> again, you should see:
</p><pre>your_username@hostname:~$ make testcirc1
g++ -Wall -c testcirc1.cpp
g++ -Wall testcirc1.o Circle.o -o testcirc1
</pre>
<p>Note that <b>Circle.cpp</b> was <b>not</b> recompiled. It did not need to be since no changes were made to it.

</p><p><b>makefiles</b> also have a default, called <b>all</b>. If you run <b>make all</b>
or just <b>make</b>, it will build everything specified for <b>all</b>. In this
case, this is <b>testcirc1</b> and <b>testcirc2</b>. Try the following:
</p><pre>your_username@hostname:~$ make clean
rm -f testcirc1 testcirc2 *.o
your_username@hostname:~$ make
g++ -Wall -c testcirc1.cpp
g++ -Wall -c Circle.cpp
g++ -Wall testcirc1.o Circle.o -o testcirc1
g++ -Wall -c testcirc2.cpp
g++ -Wall testcirc2.o Circle.o -o testcirc2
</pre>
<p>You will now have both of your test driver programs, and can run <b>test.py</b> on
them.

</p><p><b>makefiles</b> allow you to easily recompile your code after making
changes, while debugging, for example. So, from now on, you don't need to keep
typing in <b>g++</b> commands, you can simply run <b>make</b>.

</p><p>Of course, there is a lot more to <b>makefiles</b> than what has been stated above. Feel free to see what the Internet says about 
<b>makefiles</b>.</p>

<p>In the labs of this course, we will often provide you with a <b>makefile</b>, if it is needed.</p>
<p>It is interesting to note that integrated development environments (IDEs) such as MS Visual
Studio and Eclipse are essentially executing <b>makefiles</b> when you build your projects.
As a computing scientist and software developer, it's important for you to become familiar with <b>makefiles</b>, i.e., 
it is important to know what is actually happening "under the hood" of an IDE.
</p></div>
<hr>

<p>Enjoy!</p>

<hr>
<hr>

<footer>CMPT 225 - <a href="http://www.cs.sfu.ca/" target="_blank">School of Computing Science</a> - <a href="http://www.sfu.ca/" target="_blank">Simon Fraser University</a></footer>           
</body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>